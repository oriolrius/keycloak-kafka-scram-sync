package com.miimetiq.keycloak.sync.reconcile;

import com.miimetiq.keycloak.sync.domain.KeycloakUserInfo;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Represents a synchronization plan computed by the diff engine.
 * <p>
 * Contains lists of users to upsert (create/update) and principals to delete,
 * along with summary statistics. This plan is generated by comparing the current
 * state of Keycloak users against Kafka SCRAM principals.
 * <p>
 * Operations:
 * - Upserts: Users that exist in Keycloak but not in Kafka, or whose credentials need updating
 * - Deletes: Principals that exist in Kafka but not in Keycloak (orphaned accounts)
 */
public class SyncPlan {

    private final List<KeycloakUserInfo> upserts;
    private final List<String> deletes;
    private final boolean dryRun;
    private final String summary;

    /**
     * Creates a new synchronization plan.
     *
     * @param upserts list of users to upsert (create/update credentials)
     * @param deletes list of principals to delete from Kafka
     * @param dryRun  whether this is a dry-run (validation only, no execution)
     */
    public SyncPlan(List<KeycloakUserInfo> upserts, List<String> deletes, boolean dryRun) {
        this.upserts = new ArrayList<>(Objects.requireNonNull(upserts, "upserts must not be null"));
        this.deletes = new ArrayList<>(Objects.requireNonNull(deletes, "deletes must not be null"));
        this.dryRun = dryRun;
        this.summary = generateSummary();
    }

    /**
     * Gets the list of users to upsert.
     * <p>
     * These are users that exist in Keycloak and need their SCRAM credentials
     * created or updated in Kafka.
     *
     * @return immutable list of users to upsert
     */
    public List<KeycloakUserInfo> getUpserts() {
        return List.copyOf(upserts);
    }

    /**
     * Gets the list of principals to delete.
     * <p>
     * These are principals that exist in Kafka but no longer exist in Keycloak,
     * representing orphaned accounts that should be cleaned up.
     *
     * @return immutable list of principals to delete
     */
    public List<String> getDeletes() {
        return List.copyOf(deletes);
    }

    /**
     * Gets the total number of operations in this plan.
     *
     * @return total count of upserts + deletes
     */
    public int getTotalOperations() {
        return upserts.size() + deletes.size();
    }

    /**
     * Gets the number of upsert operations.
     *
     * @return count of upserts
     */
    public int getUpsertCount() {
        return upserts.size();
    }

    /**
     * Gets the number of delete operations.
     *
     * @return count of deletes
     */
    public int getDeleteCount() {
        return deletes.size();
    }

    /**
     * Checks if this plan has any operations to perform.
     *
     * @return true if there are no operations (empty diff), false otherwise
     */
    public boolean isEmpty() {
        return upserts.isEmpty() && deletes.isEmpty();
    }

    /**
     * Checks if this is a dry-run plan (validation only).
     *
     * @return true if dry-run mode, false otherwise
     */
    public boolean isDryRun() {
        return dryRun;
    }

    /**
     * Gets a human-readable summary of this sync plan.
     *
     * @return summary string with operation counts
     */
    public String getSummary() {
        return summary;
    }

    /**
     * Generates a human-readable summary of the plan.
     *
     * @return summary string
     */
    private String generateSummary() {
        if (isEmpty()) {
            return "No synchronization needed - systems are in sync";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("Sync plan: ");

        if (!upserts.isEmpty()) {
            sb.append(upserts.size()).append(" upsert(s)");
        }

        if (!deletes.isEmpty()) {
            if (!upserts.isEmpty()) {
                sb.append(", ");
            }
            sb.append(deletes.size()).append(" delete(s)");
        }

        if (dryRun) {
            sb.append(" [DRY-RUN]");
        }

        return sb.toString();
    }

    @Override
    public String toString() {
        return "SyncPlan{" +
                "upserts=" + upserts.size() +
                ", deletes=" + deletes.size() +
                ", dryRun=" + dryRun +
                ", summary='" + summary + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SyncPlan syncPlan = (SyncPlan) o;
        return dryRun == syncPlan.dryRun &&
                Objects.equals(upserts, syncPlan.upserts) &&
                Objects.equals(deletes, syncPlan.deletes);
    }

    @Override
    public int hashCode() {
        return Objects.hash(upserts, deletes, dryRun);
    }

    /**
     * Builder for creating SyncPlan instances.
     */
    public static class Builder {
        private final List<KeycloakUserInfo> upserts = new ArrayList<>();
        private final List<String> deletes = new ArrayList<>();
        private boolean dryRun = false;

        /**
         * Adds a user to the upsert list.
         *
         * @param user the user to upsert
         * @return this builder
         */
        public Builder addUpsert(KeycloakUserInfo user) {
            upserts.add(user);
            return this;
        }

        /**
         * Adds multiple users to the upsert list.
         *
         * @param users the users to upsert
         * @return this builder
         */
        public Builder addUpserts(List<KeycloakUserInfo> users) {
            upserts.addAll(users);
            return this;
        }

        /**
         * Adds a principal to the delete list.
         *
         * @param principal the principal to delete
         * @return this builder
         */
        public Builder addDelete(String principal) {
            deletes.add(principal);
            return this;
        }

        /**
         * Adds multiple principals to the delete list.
         *
         * @param principals the principals to delete
         * @return this builder
         */
        public Builder addDeletes(List<String> principals) {
            deletes.addAll(principals);
            return this;
        }

        /**
         * Sets whether this is a dry-run plan.
         *
         * @param dryRun true for dry-run mode, false otherwise
         * @return this builder
         */
        public Builder dryRun(boolean dryRun) {
            this.dryRun = dryRun;
            return this;
        }

        /**
         * Builds the SyncPlan instance.
         *
         * @return the created SyncPlan
         */
        public SyncPlan build() {
            return new SyncPlan(upserts, deletes, dryRun);
        }
    }
}
